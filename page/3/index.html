<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="活在自己梦中">
<meta property="og:type" content="website">
<meta property="og:title" content="七月流火">
<meta property="og:url" content="http://www.aimeow.com/page/3/index.html">
<meta property="og:site_name" content="七月流火">
<meta property="og:description" content="活在自己梦中">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="七月流火">
<meta name="twitter:description" content="活在自己梦中">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 七月流火 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">七月流火</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">活在自己梦中</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/26/post2/" itemprop="url">
                  对于UIColor的扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-26T02:38:48+08:00" content="2015-05-26">
              2015-05-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/26/post2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/26/post2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方UIColor的方法中，基本上都是通过RED,GREEN,BLUE三种色值去设置一种颜色。但很多时候，我们都是通过HEX值去设置一种颜色。所以我们可以通过方法去把HEX转换成我们需要的色值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (UIColor *)colorwithHexString:(NSString *)hexString alpha:(<span class="keyword">float</span>)alpha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[self colorwithHexString:hexString] colorWithAlphaComponent:alpha];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorwithHexString:(NSString *)hexString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hexString == nil || (id)hexString == [NSNull null]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    UIColor *col;</span><br><span class="line">    <span class="keyword">if</span> (![hexString hasPrefix:@<span class="string">"#"</span>]) &#123;</span><br><span class="line">        hexString = [NSString stringWithFormat:@<span class="string">"#%@"</span>, hexString];</span><br><span class="line">    &#125;</span><br><span class="line">    hexString = [hexString stringByReplacingOccurrencesOfString:@<span class="string">"#"</span></span><br><span class="line">                                                     withString:@<span class="string">"0x"</span>];</span><br><span class="line">    uint hexValue;</span><br><span class="line">    <span class="keyword">if</span> ([[NSScanner scannerWithString:hexString] scanHexInt:&amp;hexValue]) &#123;</span><br><span class="line">        col = [UIColor</span><br><span class="line">               colorWithRed:((<span class="keyword">float</span>)((hexValue &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span></span><br><span class="line">               green:((<span class="keyword">float</span>)((hexValue &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span></span><br><span class="line">               blue:((<span class="keyword">float</span>)(hexValue &amp; <span class="number">0xFF</span>))/<span class="number">255.0</span></span><br><span class="line">               alpha:<span class="number">1.0f</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        col = [UIColor clearColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/26/post1/" itemprop="url">
                  Sublime Text3安装Package Control
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-26T02:30:55+08:00" content="2015-05-26">
              2015-05-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/26/post1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/26/post1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按Ctrl+`调出console,然后粘贴以下代码到底部命令行并回车：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os; </span><br><span class="line">pf = <span class="string">'Package Control.sublime-package'</span>;</span><br><span class="line">ipp = sublime.installed_packages_path();</span><br><span class="line">urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); </span><br><span class="line">open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure></p>
<p>重启Sublime Text。 如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/12/12/post53/" itemprop="url">
                  CString与LPCWSTR、LPSTR、char*、LPWSTR等类型的转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-12-12T02:38:53+08:00" content="2011-12-12">
              2011-12-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/12/12/post53/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/12/12/post53/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一.CString与LPCWSTR<br>    两者的不同：LPCWSTR 是Unicode字符串指针，初始化时串有多大，申请空间就有多大，以后存贮若超过则出现无法预料的结果，这是它与CString的不同之处。而CString是一个串类，内存空间类会自动管理。</p>
<pre><code>CString转换成LPCWSTR

方法一：CString strFileName;

                 LPCWSTR lpcwStr = strFileName.AllocSysString();

方法二：CString str=_T(&quot;TestStr&quot;); 
                USES_CONVERSION; 
                LPCWSTR lpcwStr = A2CW((LPCSTR)str);

MFC中CString和LPSTR是可以通用，其中A2CW表示(LPCSTR)  -&gt; (LPCWSTR)，USER_CONVERSION表示用来定义一些中间变量，在使用ATL的转换宏之前必须定义该语句。

LPCWSTR转换成CString

LPCWSTR lpcwStr = L&quot;TestWStr&quot;; 
CString str(lpcwStr);
</code></pre><p>二.CString与LPSTR转换</p>
<pre><code> CString转换成LPSTR:

方法一：CString strFileName;

                LPSTR lpStr = strFileName.GetBuffer();

                strFileName.ReleaseBuffer();

 方法二：CString strFileName;

                 LPSTR lpStr = (LPSTR)(LPCSTR)strFimeName;

  LPSTR转换成CString:

                  LPSTR lpStr = L&quot;TestStr&quot;; 
                  CString str(lpStr);

  注意：CString和LPCSTR可直接转换，如下:

                 CString str;

                 LPCSTR lpcStr = (LPCSTR)str;
</code></pre><p>三.CString和char<em>转换<br>       CString转换成char</em><br>       方法一：CString str;<br>                       char<em> p = str.GetBuffer();<br>       方法二：CString str;<br>                       char</em> p = (LPSTR)(LPCSTR)str;<br>       char<em>转换成CString<br>                       char</em> p = “test”;<br>                       CString str = (“%s”,p);</p>
<p>四.String和int、float的转换</p>
<pre><code>可以使用atoi,atof,atol等函数来完成。
</code></pre><p>五.LPSTR(char*)和LPWSTR的转换</p>
<pre><code>可以使用下面的ATL宏来进行，最好是将变量定义成TCHAR、LPTSTR等T类型，可以避免转换。
</code></pre><p>ATL宏介绍：</p>
<pre><code> A2BSTR   OLE2A             T2A            W2A 
 A2COLE   OLE2BSTR    T2BSTR    W2BSTR 
 A2CT         OLE2CA         T2CA          W2CA 
 A2CW        OLE2CT         T2COLE    W2COLE 
 A2OLE       OLE2CW       T2CW         W2CT 
 A2T            OLE2T            T2OLE        W2OLE 
 A2W           OLE2W          T2W             W2T

A ：ANSI 字符串，也就是 MBCS。 
W、OLE 宽字符串，也就是 UNICODE。 
T 中间类型T。如果定义了 _UNICODE，则T表示W；如果定义了 _MBCS，则T表示A 
C const 的缩写
</code></pre><p>利用这些宏，可以快速的进行各种字符间的转换。使用前必须包含头文件，并且申明USER_CONVERSION；使用 ATL 转换宏，由于不用释放临时空间，所以使用起来非常方便。但是考虑到栈空间的尺寸（VC 默认2M），使用时要注意几点：</p>
<pre><code>1、只适合于进行短字符串的转换； 
2、不要试图在一个次数比较多的循环体内进行转换； 
3、不要试图对字符型文件内容进行转换，因为文件尺寸一般情况下是比较大的； 
4、对情况 2 和 3，要使用 MultiByteToWideChar() 和 WideCharToMultiByte()；
</code></pre><p>void Func1(LPSTR lpStr);</p>
<p>void Func2(LPWSTR lpwStr);</p>
<p>TCHAR   name[256];</p>
<p>TCHAR*   pName = new  TCHAR[256];</p>
<p>Func1(name); // Func1(pName);</p>
<p>Func2(name); // Func2(pName);</p>
<p>注意在VS2005中上面用红色标记的代码已经不成立。</p>
<p>VS2005中CString已经改为宽字符型，一些转换如下：</p>
<p>char name[10];<br> TCHAR sex[5] ;<br> char <em>p = name;<br> TCHAR </em>pw = sex;</p>
<p> LPSTR lpstr = name;<br> LPCSTR lpcstr = name;<br> lpcstr = lpstr;</p>
<p> lpstr = p;<br> p = (char<em>)sex;<br> pw = (WCHAR</em>)name;<br> LPWSTR lpwstr = (LPWSTR)lpstr;<br> lpwstr = (LPWSTR)lpcstr;<br> LPCWSTR lpcwstr = (LPCWSTR)lpstr;<br> lpcwstr = (LPCWSTR)name;</p>
<p> CString str(lpstr);<br> CString str1(lpcstr);<br> CString str2(lpwstr);<br> CString str3(lpcwstr);<br> CString str4(name);<br> CString str5(sex);</p>
<p> lpwstr = (LPWSTR)(LPCWSTR)str;<br> lpstr = (LPSTR)(LPCWSTR)str;<br> lpcstr = (LPCSTR)(LPCWSTR)str;</p>
<p> p = (char*)str.GetBuffer();<br> pw = str.GetBuffer();</p>
<p>可以看出转换更加简单了，基本上可以直接转换，A2W等宏基本上不需要啦。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/09/18/post52/" itemprop="url">
                  stdafx.h的作用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-09-18T02:38:53+08:00" content="2011-09-18">
              2011-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/09/18/post52/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/09/18/post52/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> Standard Application Fram Extend</p>
<pre><code>没有函数库，只是定义了一些环境参数，使得编译出来的程序能在32位的操作系统环境下运行。

Windows和MFC的include文件都非常大，即使有一个快速的处理程序，编译程序也要花费相当长的时间来完成工作。由于每个.CPP文件都包含相同的include文件，为每个.CPP文件都重复处理这些文件就显得很傻了。

为避免这种浪费，AppWizard和VisualC++编译程序一起进行工作，如下所示：

◎AppWizard建立了文件stdafx.h，该文件包含了所有当前工程文件需要的MFCinclude文件。且这一文件可以随被选择的选项而变化。

◎AppWizard然后就建立stdafx.cpp。这个文件通常都是一样的。

◎然后AppWizard就建立起工程文件，这样第一个被编译的文件就是stdafx.cpp。

◎当VisualC++编译stdafx.cpp文件时，它将结果保存在一个名为stdafx.pch的文件里。(扩展名pch表示预编译头文件。)

◎当VisualC++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC++不再分析Windowsinclude文件，除非你又编缉了stdafx.cpp或stdafx.h。

这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。)在这个过程中你必须遵守以下规则：

◎你编写的任何.cpp文件都必须首先包含stdafx.h。

◎如果你有工程文件里的大多数.cpp文件需要.h文件，顺便将它们加在stdafx.h(后部)上，然后预编译stdafx.cpp。

◎由于.pch文件具有大量的符号信息，它是你的工程文件里最大的文件。

如果你的磁盘空间有限，你就希望能将这个你从没使用过的工程文件中的.pch文件删除。执行程序时并不需要它们，且随着工程文件的重新建立，它们也自动地重新建立。
</code></pre>
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/08/31/post51/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-08-31T02:38:53+08:00" content="2011-08-31">
              2011-08-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/08/31/post51/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/08/31/post51/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。</p>
<p>#pragma指令对每个编译器给出了一个方法,在保持与C和C++语言完全兼容的情况下,给出主机或操作系统专有的特征。<br>依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。<br>    其格式一般为: #pragma  para<br>    其中para为参数，下面来看一些常用的参数。  </p>
<p>(1)message 参数</p>
<pre><code>message参数是我最喜欢的一个参数，它能够在编译信息输出窗口中输出相应的信息，
</code></pre><p>这对于源代码信息的控制是非常重要的。其使用方法为：  </p>
<pre><code>#pragma  message(&quot;消息文本&quot;)  
当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。  
当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，
</code></pre><p>此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏,<br>可以用下面的方法:</p>
<pre><code>#ifdef  _X86  
#pragma  message(&quot;_X86  macro  activated!&quot;)  
#endif  
我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示&quot;_86  macro  activated!&quot;。
</code></pre><p>我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。  </p>
<p>(2)另一个使用得比较多的pragma参数是code_seg</p>
<pre><code>格式如：  
#pragma  code_seg( [&quot;section-name&quot; [, &quot;section-class&quot;] ] )  
它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。  
</code></pre><p>(3)#pragma once  (比较常用) </p>
<pre><code>只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，
</code></pre><p>但是考虑到兼容性并没有太多的使用它。 </p>
<p>(4)#pragma  hdrstop</p>
<pre><code>表示预编译头文件到此为止，后面的头文件不进行预编译。BCB可以预编译头文件以加快链接的速度，
</code></pre><p>但如果所有头文件都进行预编译又可能占太多磁盘空间，所以使用这个选项排除一些头文件。<br>    有时单元之间有依赖关系，比如单元A依赖单元B，所以单元B要先于单元A编译。<br>你可以用#pragma  startup指定编译优先级，如果使用了#pragma  package(smart_init)，<br>BCB就会根据优先级的大小先后编译。   </p>
<p>(5)#pragma  resource  “*.dfm”</p>
<pre><code>表示把*.dfm文件中的资源加入工程。*.dfm中包括窗体  
</code></pre><p>外观的定义。   </p>
<p>(6)#pragma  warning( disable: 4507 34; once: 4385; error: 164 )</p>
<pre><code>等价于：  
#pragma  warning( disable: 4507 34 )    //  不显示4507和34号警告信息  
#pragma  warning( once: 4385 )          //  4385号警告信息仅报告一次  
#pragma  warning( error: 164 )          //  把164号警告信息作为一个错误。 

同时这个pragma  warning  也支持如下格式：  
#pragma  warning( push [, n ] )  
#pragma  warning( pop )  
这里n代表一个警告等级(1---4)。  
#pragma  warning( push )保存所有警告信息的现有的警告状态。  
#pragma  warning( push, n )保存所有警告信息的现有的警告状态，并且把全局警告等级设定为n。    
#pragma  warning( pop )向栈中弹出最后一个警告信息，在入栈和出栈之间所作的一切改动取消。例如：  
#pragma  warning( push )  
#pragma  warning( disable: 4705 )  
#pragma  warning( disable: 4706 )  
#pragma  warning( disable: 4707 )  
//.......  
#pragma  warning(  pop  )    
在这段代码的最后，重新保存所有的警告信息(包括4705，4706和4707)。 
</code></pre><p>(7)#pragma  comment(…) </p>
<pre><code>该指令将一个注释记录放入一个对象文件或可执行文件中。  
</code></pre><p>常用的lib关键字，可以帮我们连入一个库文件。如：</p>
<pre><code>#pragma  comment(lib, &quot;comctl32.lib&quot;)
#pragma  comment(lib, &quot;vfw32.lib&quot;)
#pragma  comment(lib, &quot;wsock32.lib&quot;)
</code></pre><p>每个编译程序可以用#pragma指令激活或终止该编译程序支持的一些编译功能。</p>
<p>例如，对循环优化功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span>  loop_opt(on)     <span class="comment">//  激活  </span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span>  loop_opt(off)    <span class="comment">//  终止</span></span></span><br></pre></td></tr></table></figure></p>
<p>有时，程序中会有些函数会使编译器发出你熟知而想忽略的警告，<br>如“Parameter  xxx  is  never  used  in  function  xxx”，可以这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma  warn  —100         //  Turn  off  the  warning  message  for  warning  #100  </span></span><br><span class="line">int  insert_record(REC  *r)  </span><br><span class="line">&#123;  /*  <span class="keyword">function</span>  body  */  &#125;  </span><br><span class="line"><span class="comment">#pragma  warn  +100          //  Turn  the  warning  message  for  warning  #100  back  on</span></span><br></pre></td></tr></table></figure></p>
<p>函数会产生一条有唯一特征码100的警告信息，如此可暂时终止该警告。 </p>
<p>每个编译器对#pragma的实现不同，在一个编译器中有效在别的编译器中几乎无效。可从编译器的文档中查看。</p>
<p>补充 —— #pragma pack 与 内存对齐问题</p>
<pre><code>许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k
</code></pre><p>(通常它为4或8)的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。</p>
<pre><code>Win32平台下的微软C编译器(cl.exe for 80x86)在默认情况下采用如下的对齐规则: 
任何基本数据类型T的对齐模数就是T的大小，即sizeof(T)。比如对于double类型(8字节)，
</code></pre><p>就要求该类型数据的地址总是8的倍数，而char类型数据(1字节)则可以从任何一个地址开始。</p>
<pre><code>Linux下的GCC奉行的是另外一套规则(在资料中查得，并未验证，如错误请指正):
任何2字节大小(包括单字节吗?)的数据类型(比如short)的对齐模数是2，而其它所有超过2字节的数据类型
</code></pre><p>(比如long,double)都以4为对齐模数。</p>
<pre><code>ANSI C规定一种结构类型的大小是它所有字段的大小以及字段之间或字段尾部的填充区大小之和。
</code></pre><p>填充区就是为了使结构体字段满足内存对齐要求而额外分配给结构体的空间。那么结构体本身有什么对齐要求吗？<br>有的，ANSI C标准规定结构体类型的对齐要求不能比它所有字段中要求最严格的那个宽松，可以更严格。</p>
<p>如何使用c/c++中的对齐选项</p>
<pre><code>vc6中的编译选项有 /Zp[1|2|4|8|16] ，/Zp1表示以1字节边界对齐，相应的，/Zpn表示以n字节边界对齐。
</code></pre><p>n字节边界对齐的意思是说，一个成员的地址必须安排在成员的尺寸的整数倍地址上或者是n的整数倍地址上，取它们中的最小值。<br>也就是：<br>    min ( sizeof ( member ),  n)</p>
<pre><code>实际上，1字节边界对齐也就表示了结构成员之间没有空洞。
/Zpn选项是应用于整个工程的，影响所有的参与编译的结构。
要使用这个选项，可以在vc6中打开工程属性页，c/c++页，选择Code Generation分类，在Struct member alignment可以选择。

要专门针对某些结构定义使用对齐选项，可以使用#pragma pack编译指令:
</code></pre><p>(1) #pragma  pack( [ n ] )</p>
<pre><code>该指令指定结构和联合成员的紧凑对齐。而一个完整的转换单元的结构和联合的紧凑对齐由/Zp 选项设置。
</code></pre><p>紧凑对齐用pack编译指示在数据说明层设置。该编译指示在其出现后的第一个结构或联合说明处生效。<br>该编译指示对定义无效。<br>    当你使用#pragma  pack ( n ) 时, 这里n 为1、2、4、8 或16。<br>    第一个结构成员之后的每个结构成员都被存储在更小的成员类型或n 字节界限内。<br>如果你使用无参量的#pragma  pack, 结构成员被紧凑为以/Zp 指定的值。该缺省/Zp 紧凑值为/Zp8 。</p>
<p>(2) 编译器也支持以下增强型语法:</p>
<pre><code>#pragma  pack( [ [ { push | pop } , ] [ identifier, ] ] [ n] )

若不同的组件使用pack编译指示指定不同的紧凑对齐, 这个语法允许你把程序组件组合为一个单独的转换单元。
</code></pre><p>带push参量的pack编译指示的每次出现将当前的紧凑对齐存储到一个内部编译器堆栈中。<br>    编译指示的参量表从左到右读取。如果你使用push, 则当前紧凑值被存储起来;<br>如果你给出一个n 的值, 该值将成为新的紧凑值。若你指定一个标识符, 即你选定一个名称,<br>则该标识符将和这个新的的紧凑值联系起来。</p>
<pre><code>带一个pop参量的pack编译指示的每次出现都会检索内部编译器堆栈顶的值,并且使该值为新的紧凑对齐值。
</code></pre><p>如果你使用pop参量且内部编译器堆栈是空的,则紧凑值为命令行给定的值, 并且将产生一个警告信息。<br>若你使用pop且指定一个n的值, 该值将成为新的紧凑值。若你使用p o p 且指定一个标识符,<br>所有存储在堆栈中的值将从栈中删除, 直到找到一个匹配的标识符, 这个与标识符相关的紧凑值也从栈中移出,<br>并且这个仅在标识符入栈之前存在的紧凑值成为新的紧凑值。如果未找到匹配的标识符,<br>将使用命令行设置的紧凑值, 并且将产生一个一级警告。缺省紧凑对齐为8 。</p>
<p>   pack编译指示的新的增强功能让你编写头文件, 确保在遇到该头文件的前后的<br>紧凑值是一样的。</p>
<p>(3) 栈内存对齐</p>
<pre><code>在vc6中栈的对齐方式不受结构成员对齐选项的影响。它总是保持对齐，而且对齐在4字节边界上。
</code></pre>
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/08/26/post50/" itemprop="url">
                  Effective C++ (第20条：尽量使用“引用常量”传参，而不是传值)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-08-26T02:38:53+08:00" content="2011-08-26">
              2011-08-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/08/26/post50/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/08/26/post50/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第20条：     尽量使用“引用常量”传参，而不是传值</p>
<p>默认情况下， C++ 为函数传入和传出对象是采用传值方式的（这是由 C 语言继承而来的特征）。除非你明确使用其他方法，函数的形式参数总会通过复制实在参数的副本来创建，并且，函数的调用者得到的也是函数返回值得一个副本。这些副本是由对象的拷贝构造函数创建的。这使得“传值”成为一项代价十分昂贵的操作。请观察下边的示例中类的层次结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  Person();                      <span class="comment">// 为简化代码省略参数表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~Person();             <span class="comment">// 第 7 条解释了它为什么是虚函数</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> address;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student: <span class="keyword">public</span> Person &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  Student();                     <span class="comment">// 再次省略参数表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~Student();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> schoolName;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> schoolAddress;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请观察下面的代码，这里我们调用一个名为 validateStudent 的 函数，通过为这一函数传进一个 Student 类型的参数（传值方式），它将返回这一学生的身份是否合法：</p>
<p>bool validateStudent(Student s);// 通过传值方式接受一个 Student 对象</p>
<p>Student plato;                  // 柏拉图是苏格拉底的学生</p>
<p>bool platoIsOK = (plato);   // 调用这一函数</p>
<p>在这个函数被调用时将会发生些什么呢？</p>
<p>很显然地，在这一时刻，通过调用 Student 的拷贝构造函数，可以将这一函数 的 s 参数初始化为 plato 的值 。同样显然的是， s 在 validateStudent 返回的时候将被销毁。所以这一函数中传参的开销就是调用一次 Student 的拷贝构造函数和一次 Student 的析构函数。</p>
<p>但是上边的分析仅仅是冰山一角。一个 Student 对象包含两个 string 对象，所以每当你构造一个 Student 对象时，你都必须构造两个 string 对象。同时，由于 Student 类是从 Person 类继承而来，所以在每次构造 Student 对象时，你都必须再构造一个 Person 对象。一个 Person 对象又包含两个额外的 string 对象，所以每次对 Person 的构造还要进行额外的两次 string 的构造。最后的结果是，通过传值方式传递一个 Student 对象会引入以下几个操作：调用一次 Student 的拷贝构造函数，调用一次 Person 的拷贝构造函数，调用四次 string 的拷贝构造函数。在 Student 的这一副本被销毁时，相应的每次构造函数调用都对应着一次析构函数的调用。因此我们看到：通过传值方式传递一个 Student 对象总体的开销究竟有多大？调用六次构造函数和六次析构函数！</p>
<p>下面向你介绍正确的方法，这一方法才会使函数拥有期望的行为。毕竟你期望的是所有对象以可靠的方式进行初始化和销毁。然而，如果可以绕过所有这些构造函数和析构函数将是件很惬意的事情。那就是：通过引用常量传递参数：</p>
<p>bool (const Student&amp; s);</p>
<p>这样做效率会提高很多：由于不会创建新的对象，所以就不会存在构造函数或析构函数的调用。改进的参数表中的 const 是十分重要的。由于早先版本的 validateStudent 通过传值方式接收 Student 参数，所以调用者了解：无论函数对于传入的 Student 对象进行什么样的操作，都不会对原对象造成任何影响， validateStudent 仅仅会对对象的副本进行修改。而改进版本中 Student 对象是以引用形式传入的，有必要将其声明为 const 的，因为如果不这样，调用者就需要关心传入 validateStudent 的 Student 对象有可能会被修改。</p>
<p>通过引用传参也可以避免“截断问题”。当一个派生类的对象以一个基类对象的形式传递（传值方式）时，基类的拷贝构造函数就会被调用，此时，这一对象的独有特征——使它区别于基类对象的特征会被“截掉”。剩下的只是一个简单的基类对象，这并不奇怪，因为它是由基类构造函数创建的。这肯定不是你想要的。请看下边的示例，假设你正在使用一组类来实现一个图形视窗系统：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Window &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">// return name of window</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// draw window and contents</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WindowWithScrollBars: <span class="keyword">public</span> Window &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所有的 Window 对象都有一个名字，可以通过 name 函数取得这个名字，所有的视窗可以被显示出来，可以通过调用 display 实现。 display 是虚函数，这一点告诉你简单基类 Window 的对象与派生出的 WindowWithScrollBars 对象的显示方式是不一样的。（参见第 34 和 36 条）</p>
<p>现在，假设你期望编写一个函数来打印出当前窗口的名字然后显示这一窗口。下面是错误的实现方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span><span class="comment">// 错误 ! 参数传递的对象将被截断。</span></span><br><span class="line"></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name();</span><br><span class="line"></span><br><span class="line">  w.display();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>考虑一下当你将一个 WindowWithScrollBars 对象传入这个函数时将会发生些什么：</p>
<p>WindowWithScrollBars wwsb;</p>
<p>printNameAndDisplay(wwsb);</p>
<p>参数 w 将被构造——还记得么？它是通过传值方式传入的——就像一个 Window 对象，使 wwsb 具体化的独有信息将被截掉。无论传入函数的对象的具体类型是什么，在 printNameAndDisplay 的内部， w 将总保有一个 Window 类的对象的身份（因为它本身就是一个 Window 的对象）。特别地，在 printNameAndDisplay 内部对 display 的调用总会是 Window::display ，而永远不会是 WindowWithScrollBars::display 。</p>
<p>解决截断问题的方法是：通过引用常量传参：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="keyword">const</span> Window&amp; w)</span></span><br><span class="line"></span><br><span class="line"></span>&#123;                               <span class="comment">// 工作正常，参数将不会被截断。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name();</span><br><span class="line"></span><br><span class="line">  w.display();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在 w 的类型就是传入视窗对象的精确类型。</p>
<p>揭开 C++ 编译器的面纱，你将会发现引用通常情况下是以指针的形式实现的，所以通过引用传递通常意味着实际上是在传递一个指针。因此，如果传递一个内建数据类型的对象（比如 int ），传值会被传递引用更为高效。那么，对于内建数据类型，当你在传值和传递常量引用之间徘徊时，传值方式不失为一个更好的选择。迭代器 和 STL 中的函数对象都是如此，这是因为它们设计的初衷就是更适于传值，这是 C++ 的惯例。实现迭代器和函数对象的人员有责任考虑复制时的效率问题和截断问题。（这就是一个“使用哪种规则，取决于当前使用哪一部份的 C++ ”，参见第 1 条）</p>
<p>内建数据类型体积较小，所以一些人得出这样的结论：所有体积较小的类型都适合使用传值，即使它们是用户自定义的。这是一个不可靠的推理。仅仅通过一个对象体积小并不能判定调用它的拷贝构造函数的代价就很低。许多对象——包括大多数 STL 容器——其中仅仅包含一个指针和很少量的其它内容，但是复制这样的对象的同时，它所指向的所有内容都需要复制。这将会是一件十分昂贵的事情。</p>
<p>即使体积较小的对象的拷贝构造函数不会带来昂贵的开销，它也会引入性能问题。一些编译器对内建数据类型和用户自定义数据类型是分别对待的，即使它们的原始表示方式完全相同。比如说一些编译器很乐意将一个单纯的 double 值放入寄存器中，这是语言的常规，但将仅包含一个 double 值的对象放入寄存器时，编译器就会报错了。当你遇到这种事情时，你可以使用引用传递这类对象，因为编译器此时一定会将指针（引用的具体实现）放入寄存器中。</p>
<p>小型用户自定义数据类型不适用于传值方式还有一个理由，那就是：作为用户自定义类型，它们的大小并不是固定的。现在很小的类型在未来的版本中可能会变得很大，这是因为它的内部实现方式可能会改变。即使是你更改了 C++ 语言的具体实现都可能会影响到类型的大小。比如，在我编写上面的示例的时候，一些对标准库中 string 实现的大小竟然达到了另一些的七倍。</p>
<p>总体上讲，只有内建数据类型、 STL 迭代器和函数对象类型适用于传值方式。对于所有其它的类型，都应该遵循本条款中的建议：使用引用常量传参，而不是传值。</p>
<p>牢记在心</p>
<p>尽量使用引用常量传参，而不是传值方式。因为传引用更高效，而且可以避免“截断问题”。 对于内建数据类型、 STL 迭代和函数对象类型，这一规则就不适用了，对它们来说通常传值方式更实用。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/08/26/post49/" itemprop="url">
                  到底什么时候用指针或是引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-08-26T02:38:53+08:00" content="2011-08-26">
              2011-08-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/08/26/post49/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/08/26/post49/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.问题提出：</p>
<p>当一个类的对象作为实参数传递时，使用值传递和引用传递有什么区别？</p>
<pre><code>比如: DateType ExampleFun(CString &amp;strFileName,...)与

      DateType ExampleFun(CString strFileName,...)
</code></pre><p>解答之前，我们先来看2个基本的概念：形参和实参。</p>
<p>-&gt;通俗的讲:形参是形式上的参数,实参是实际的参数;</p>
<p>-&gt;详细的讲:形参只是对实参的一种抽象类型描述,只是声明一个函数(方法)能接受什么类型的实参,而不确定接受的实参具体内容是多少;</p>
<p>实参就是传递给函数(方法)对应形参的具体内容(值),形参的初始指(内容)由实参决定.形参在函数(方法)结束返回后就被释放了.</p>
<p>2.参数传递方式分:传值和传址;</p>
<p>1).传值方式,只是将实参的值的拷贝传递给函数(方法),在方法内对形参进行操作,其对象是实参的拷贝,对实参不能造成影响.在方法结束返回后,形参被释放丢弃,实参的内容并不会改变;</p>
<p>2).传址方式,将实参的地址传递给函数(方法),在方法内对形参进行操作即等于对实参进行相同的操作,在方法结束返回后,形参同样被释放,实参的内容将会是对形参进行操作的结果. </p>
<p>而传址方式，又可以细分为：引用传递(pass-by-reference) , 指针传递(pass-by-pointer)</p>
<p>引用其实就是对象的别名，传对象的引用,用于把一个对象的地址作为参数传过去，而不是对象本身。</p>
<p>这是我们就明白了前面问题的答案：传递引用，避免了一次实参到形参的拷贝，提高了效率。</p>
<p>3.关于何时使用引用参数？</p>
<p>（1）使用引用参数的主要原因有：</p>
<p>  程序员能够修改调用函数中的数据对象</p>
<p>  通过传递引用而不是整个数据对象，可以提高运行速度</p>
<p>（2）对于使用传递的值而不做修改的函数：</p>
<p>  如果数据对象很小，如内置数据对象，则按值传递</p>
<p>  如果数据对象是数组，则使用指针，并将指针声明为指向const的指针</p>
<p>  如果数据对象是较大的结构则使用const指针或const引用，以提高效率，节省复制结构所需的时间和空间</p>
<p>如果数据对象是类对象则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因，因此传递类对象的标准方式是按照引用传递。</p>
<p>（3）对于修改调用函数中数据的函数：</p>
<p> 如果数据对象是内置数据类型则使用指针。</p>
<p> 如果数据对象是数组则只能使用指针</p>
<p> 如果数据对象是结构则使用引用或指针</p>
<p> 如果数据对象是类对象则使用引用</p>
<p>4.总结：</p>
<p>在c/c++编程中，到底什么时候该用指针来传递参数呢？总结如下：</p>
<ol>
<li><p>需要改变实参的时候, 只能用指针. </p>
</li>
<li><p>传递大型结构并且”只读”其元素的时候, </p>
</li>
</ol>
<p>因为大型结构通过值传递, 需要拷贝其每个元素, 这样效率太低. </p>
<ol>
<li><p>需要遍历数组或频繁引用其元素时, 这样效率比使用下标高. </p>
</li>
<li><p>动态分配空间时, 必须使用指针. </p>
</li>
<li><p>传递数组时, 必须使用指针. </p>
</li>
<li><p>函数返回指针时, 比如fopen </p>
</li>
<li><p>另外，有时候需要使用二级指针，即指针的指针，例如: </p>
<p>MemAllocate(char *a){ </p>
<p> a=(char *)malloc(sizeof(char)); </p>
</li>
</ol>
<p>} </p>
<p>当调用此函数进行内存分配时，发现不能分配内存不能成功，因为此时对于a来说，形参改变了，但实参并不会改变，他们对应于不同的内存单元。正确的写法应该是: </p>
<pre><code>MemAllocate(char **a){ 

*a=(char *)malloc(sizeof(char)); 
</code></pre><p>} </p>
<p>这样就能够正确地分配内存了。 </p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/08/25/post48/" itemprop="url">
                  C++中冒号的用法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-08-25T02:38:53+08:00" content="2011-08-25">
              2011-08-25
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/08/25/post48/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/08/25/post48/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　1.冒号（:）用法</p>
<p>　　（1）表示机构内位域的定义（即该变量占几个bit空间）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">typedef</span> <span class="keyword">struct</span> _XXX&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> a:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">　　&#125; ; XXX</span><br></pre></td></tr></table></figure></p>
<p>　　（2）构造函数后面的冒号起分割作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型。<br>　　<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">　　<span class="keyword">struct</span> _XXX&#123;</span><br><span class="line"></span><br><span class="line">　　_XXX() : y(<span class="number">0xc0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　（3） public:和private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下一个”public:”或”private:”出现为止。”private:”为默认处理。</p>
<p>　　（4）类名冒号后面的是用来定义类的继承。</p>
<p>　　class 派生类名 : 继承方式 基类名</p>
<p>　　{</p>
<p>　　派生类的成员</p>
<p>　　};</p>
<p>　　继承方式：public、private和protected，默认处理是public。</p>
<p>　　2．双冒号（::）用法</p>
<p>　　（1）表示“域操作符”</p>
<p>　　例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，</p>
<p>　　就要写成void A::f()，表示这个f()函数是类A的成员函数。</p>
<p>　　（2）直接用在全局函数前，表示是全局函数</p>
<p>　　例：在VC里，你可以在调用API 函数里，在API函数名前加：：</p>
<p>　　（3）表示引用成员函数及变量，作用域成员运算符</p>
<p>　　例：System::Math::Sqrt() 相当于System.Math.Sqrt()</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/08/18/post44/" itemprop="url">
                  能大大提升工作效率和时间效率的9个重要习惯
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-08-18T02:38:53+08:00" content="2011-08-18">
              2011-08-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/08/18/post44/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/08/18/post44/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现代人都很忙，但忙的可能没有效率，可能在“忙人”摸象，也就是瞎忙。也许你的效率可以提升20倍，也许你的激情和潜能可以提升10倍！秘诀就在于目标管理、时间管理、精力管理、如何在短时间内完成更多的事情、如何从痛苦的修行中悟道、如何尊崇内心的自由、如何有更多的时间去享受生活、如何动态平衡工作和生活？！这里有能大大提升工作效率和时间效率的几个重要的工作习惯：</p>
<ol>
<li><p>每天一上班就进入状态，不要浏览网页，快速聚焦最重要的工作项上面<br>一些好习惯的养成，常常有助于工作效率的提高。比如，每天一进入办公室就进入状态，浏览一下邮件，列出今天要完成的工作，首先集中于做最最重要的事情。不要一上班就浏览网页和新闻，来自朋友的消息和新闻往往会浪费不少时间并分散你的精力，如果你忍不住总是想要上网溜达溜达，这时候应该告诉自己：“晚几个小时看，那些新闻不会消失的！” 实践证明，一上班就聚焦在最重要的工作上往往能最高效最快速的解决问题，因为你有热情，但热情和焦点很容易被分散，解决的秘诀就在于不让杂事分散自己的注意力、焦点和热情。总之，记住了：每天一到公司先做最重要的事情！</p>
</li>
<li><p>分类集中处理事项，大大提升时间利用效率<br>你每天所要处理的工作，如果仔细想来无非有两种：事务型和思考型。如果将你所要做的工作做如此划分，区别对待，也许你会收到事半功倍的效果。事务型的工作不用太动脑子，只要按照熟悉的流程或程序做下去就可以，而且不怕被干扰和中断，如收发e-mail、写信、填写工作报表、备忘录等，这些例行公事、性质相近的事情可以集中在同一个时间段来处理，即使在精神状态不佳的情况下也能完成。而对于那些需要集中精力、一气呵成的思考型工作，则要谨慎对待，在做之前要进行充分的思考，不停地想，苦思之后方有灵感闪现，这时要安排精力旺盛、思路敏捷，而且不易被干扰的时间段集中去做。</p>
</li>
<li><p>制定工作计划之外给自己一个倒计时产生时间紧迫感<br>每天面对大量的工作，谁都不免产生“丢三落四”、忙而无序的状况；如果会工作，养成定时作计划的习惯，效果是大大不一样的。 要善于管理自己的工作，可以准备一个记事本，对自己每月的工作计划、每周的工作计划进行规划和跟踪管理。每月之末，抽出一定的时间思考一下下个月的工作重点和计划安排。制定工作计划，关键是要会分解目标，把制定的月目标分解到一个周，一个周的目标再分解到每一天。也许看上去是一个很庞大的，担心完成不了的工作目标，经过这样的层层分解后，结果发现，原来要实现这个目标并不是很难；这样工作起来才不会感到有很大的压力。</p>
</li>
</ol>
<p>此外，制定工作计划之外，要给自己设定一个倒计时，利用倒计时所产生的紧迫感。这是心理学家推荐的自我激励方法。这种倒计时所产生的紧迫感能激发你的决断力和专注力，调动你的情绪和潜能。</p>
<ol>
<li>学会沟通，微笑沟通，工作效率提升也需要沟通获取良好的外部环境和资源<br>在一个公司里或者团队里，遇到最多的时间管理上的问题是什么？沟通问题。沟通首先要学会微笑，微笑首先要敞开心扉，用一个包容的心态和接纳的心态来沟通。微笑、自信，能产生神奇的效果，笑对世界，世界就会对你微笑；自信，周围的人会更多的支持你。</li>
</ol>
<p>每天用一定的时间来和同事、上级沟通，有良好的沟通心态、学会倾听，就能获得积极的沟通效果，工作软环境、工作需要的资源就能获得支持！这对工作效率的提升有非常大的作用。记住：很多时候有效沟通可能比抓紧时间做事还重要！很多有经验的人都知道：领导布置下来一项任务之后，先和领导沟通好预期的结果和方式很重要 ～ 只有当你真正明白了要做什么，怎么去做的时候，再去行动，这样返工的几率就低的多了，自然效率也就高了。这就是所谓的“磨刀不误砍柴工”！</p>
<ol>
<li>提升自己的专业能力，能力强才有解决问题的效率<br>我想这个道理大家都懂的，一个刚毕业的业务不熟、技术不精的人去解决一个问题往往半天都找不到门道，半天一天的时间可能要被白白浪费在知道自己要干什么上面。有时候，要知道自己要干什么也是一件很难的事情，需要对业务和需求、技术等多方面的理解，而不知道自己要干什么更不用谈工作效率了。即使知道了要干什么，下一步还有怎么做的问题…. 这一切都要求我们提升自己的专业能力，没有专业能力，强工作效率无从谈起。如果你的专业能力越强，经验约丰富，那么你做一件事情比别人消耗的时间就越少，这时候你就需要考虑是不是可以接受更大的挑战，多做一些重要但是不紧急的事情。</li>
</ol>
<ol>
<li><p>保持工作环境的有序和整洁<br>实践证明，优雅整洁的工作环境、打造高效健康的工作区能大大激发工作的热情和潜能，这就是为什么美国的大公司纷纷在工作环境和装修上大请设计师的原因了。工作环境不仅会影响到工作效率，还会影响工作中的创造性。美国管理大师坎特为不景气的公司管理人员提出的第一个建议往往是让他们把工作地点重新粉刷或是清洁一遍。这也是给你自己贴上成功标签的一种方法。她说：“环境会激发人们向更高的目标看齐。不要认为给自己换个新发型或是买件时髦的衣服是轻浮虚荣的，你这样做不是为了炫耀，而是为了在胜利到来之前为自己树立信心。</p>
</li>
<li><p>学会自我暗示提升自信，好情绪能提升工作效率<br>自信心就是对良性结果的期待! 工作中没有什么勇敢不勇敢，如果出了问题就必须面对！必须解决！遇到挫折的时候抛弃所有的主观情绪，只追问自己：如何解决问题？（这很难，需要很深厚的功力）在想办法解决的过程中，要有信心，要进行自我暗示，相信一定会解决一定能够解决，这种对良性结果的期待就是自信心，这种自信能大大提升工作效率。而坏的情绪好坏往往会影响到工作状态，要求自己尽量不要把一些不好的情绪带进工作里，当然谁也不可避免遭遇气愤、低落的时刻，但要学会控制。每当这时，闭上眼睛几分钟，告诉自己：“只要不发作，就又战胜自己了”。能够管理自己的情绪了，也就意味着在走向成熟。 此外，要学会把生活和工作上的事情分开。</p>
</li>
</ol>
<p>通常影响我们效率的，不是繁杂的任务和时间管理的问题，而是我们的情绪！我们通常被情绪所左右，压根不想工作，不想干活，拒绝合作，这才是我们拖延和被动的原因。通常让我们感到疲惫的，不是劳累，而是索然无味。所以，跳槽去一个你喜欢、投入热情的工作中去吧，如果不热爱你的工作，何来工作效率？</p>
<ol>
<li><p>要学会拒绝<br>当我刚开始工作的时候，我非常急切的想要去讨好别人。这也就是说，我几乎不能去回绝别人对我的要求。我加了很多班，但是还是不能完成他们交代给我的所有事情。结果他们表示不满意，而我也表示要崩溃了。如果你从不回绝别人，你的答应就显得毫无意义。承担能力所及的事情，如果别人不停地指派给你更多的事情，你需要明确的表示那意味着将会耽误其他的工作。为了应付这种事情，我会随身携带一张列有待办事项的纸（To-do list)。当人们叫我去做什么事情的时候，我就给他们看这张纸，并且问他们我应该为他们挤掉哪个事情。这是我用来拒绝别人的一种好办法。</p>
</li>
<li><p>彻底放松，休息<br>也许你不相信，提升工作效率的最后一点是彻底放松，休息。你放松了，休息好了，就能有效率。相反，连续加班，持续高压，这种工作效率是不可持续的。工作是一项长跑，不是50米冲刺。一次彻底的放松，才能更有精力去工作。这样的事情很常见，问题的核心是：什么才是最有效的彻底放松？我推荐几个：冥想（静坐）、和知心朋友聊天、散步、音乐、旅行…. 所有最适合自己的让你最放松的放松就可以了。休假的时候，就彻底忘记工作，告诉自己：“工作是忙不完的，没有你，公司还是一样转动，也许还转的更快呢！高效工作的目的是什么：不就是为了省出时间来享受生活么”</p>
</li>
</ol>
<p>原文：<a href="http://www.cnblogs.com/Mainz/archive/2011/06/12/2078810.html" target="_blank" rel="external">http://www.cnblogs.com/Mainz/archive/2011/06/12/2078810.html</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2011/08/18/post47/" itemprop="url">
                  数据结构：栈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-08-18T02:38:53+08:00" content="2011-08-18">
              2011-08-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2011/08/18/post47/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2011/08/18/post47/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“栈”是一种先进后出(First In Last Out)或后进先出(Last In First Out)的数据结构。日常生活中也常能见到它的实例，如压入弹夹的子弹，最先压进去的子弹最后射出，而最后压入的子弹则最先发射出来。</p>
<pre><code>“栈”是一种只能在一端进行插入和删除的特殊的线性表，进行插入和删除的一端称为“栈顶”，而不动的一端称为栈底(如下图)。插入的操作也称为进栈(PUSH)，删除的操作也称为出栈(POP)。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> NodeType&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    NodeType *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> LinkStrack&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        NodeType *top;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LinkStrack();</span><br><span class="line">        ~LinkStrack();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ElemType e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;        </span><br><span class="line">        <span class="function">ElemType <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">ElemType <span class="title">popTop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStrack :: LinkStrack()&#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    top = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkStrack :: ~LinkStrack()&#123;</span><br><span class="line">    setEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> LinkStrack :: push(ElemType e)&#123;</span><br><span class="line">    NodeType *node = <span class="keyword">new</span> NodeType();</span><br><span class="line">    node -&gt; data = e;</span><br><span class="line">    node -&gt; next = top;</span><br><span class="line">    top = node;</span><br><span class="line">    length += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> LinkStrack :: setEmpty()&#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    NodeType *down,*up;</span><br><span class="line">    up = top;</span><br><span class="line">    down = top -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(down != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> up;</span><br><span class="line">        up = down;</span><br><span class="line">        down = up -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> LinkStrack :: isEmpty()&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ElemType LinkStrack :: pop()&#123;</span><br><span class="line">    NodeType *node;</span><br><span class="line">    node = top;</span><br><span class="line">    top = top -&gt; next;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    length -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ElemType LinkStrack :: popTop()&#123;</span><br><span class="line">    NodeType *up,*down;</span><br><span class="line">    up = top;</span><br><span class="line">    down = top -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(down != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        up = down;</span><br><span class="line">        down = down -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> up -&gt; data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkStrack :: display()&#123;</span><br><span class="line">    NodeType *node = top;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"length:"</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node -&gt; data &lt;&lt; endl;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    LinkStrack a;</span><br><span class="line">    a.push(<span class="number">2135</span>);</span><br><span class="line">    a.push(<span class="number">21354</span>);</span><br><span class="line">    a.push(<span class="number">2356</span>);</span><br><span class="line">    a.push(<span class="number">34567</span>);</span><br><span class="line">    a.push(<span class="number">21356785</span>);</span><br><span class="line">    a.pop();</span><br><span class="line">    a.push(<span class="number">45678</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.popTop() &lt;&lt; endl;</span><br><span class="line">    a.display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7ktwh7.com1.z0.glb.clouddn.com/8762EAB5-EE65-4481-8667-07C2E55A9ACB.png"
               alt="Aimeow" />
          <p class="site-author-name" itemprop="name">Aimeow</p>
          <p class="site-description motion-element" itemprop="description">活在自己梦中</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">54</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/simon4761" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aimeow</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"aimeow4761"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  


</body>
</html>
